LOB_lpsolve <- function(LOBpeaklist,choose_class=NULL,save.files=FALSE) {

  library(lpSolve)
  library(ggplot2)

  ### Check Inputs ###

  if (!class(LOBpeaklist)=="data.frame") {

    stop("Input 'LOBpeaklist' is not an 'data.frame' object.\n",
         "Please use a data.frame generated by 'getLOBpeaklist'.")

  }

  # if (is.null(LOBpeaklist$match_ID)) {
  #
  #   stop("Input data.frame does not contain a 'match_ID' column.",
  #        "Please use a data.frame generated by 'getLOBpeaklist'.")
  #
  # }

  if (is.null(LOBpeaklist$compound_name)) {

    stop("Input data.frame does not contain a 'compound_name' column.",
         "Please use a data.frame generated by 'getLOBpeaklist'.")

  }

  if (is.null(LOBpeaklist$LOBdbase_mz)) {

    stop("Input data.frame does not contain a 'LOBdbase_mz' column.",
         "Please use a data.frame generated by 'getLOBpeaklist'.")

  }

  if (is.null(LOBpeaklist$peakgroup_rt)) {

    stop("Input data.frame does not contain a 'peakgroup_rt' column.",
         "Please use a data.frame generated by 'getLOBpeaklist'.")

  }

  if (is.null(LOBpeaklist$FA_total_no_C)) {

    stop("Input data.frame does not contain a 'FA_total_no_C' column.",
         "Please use a data.frame generated by 'getLOBpeaklist'.")

  }

  if (is.null(LOBpeaklist$FA_total_no_DB)) {

    stop("Input data.frame does not contain a 'FA_total_no_DB' column.",
         "Please use a data.frame generated by 'getLOBpeaklist'.")

  }

  ### Format our input in a 'run' dataframe
  return <- LOBpeaklist
  LOBpeaklist <- LOBpeaklist[which(LOBpeaklist$degree_oxidation==0),]

  if (is.null(choose_class)==FALSE) {
    if(choose_class%in%unique(LOBpeaklist$species)==FALSE){
      stop("Chosen 'choose_class' does not appear in the 'species' column of data.frame.")
    }else{
      LOBpeaklist <- LOBpeaklist[which(LOBpeaklist$species==choose_class),]}
  }else{
    LOBpeaklist <- subset(LOBpeaklist, subset = lipid_class %in% c("IP_DAG","IP_MAG","TAG"))
  }
  # Put what we need in a dataframe
  PRErun  <- data.frame(LOBpeaklist$match_ID,
                        LOBpeaklist$compound_name,
                        LOBpeaklist$LOBdbase_mz,
                        LOBpeaklist$peakgroup_rt,
                        LOBpeaklist$FA_total_no_C,
                        LOBpeaklist$FA_total_no_DB,
                        LOBpeaklist$species)

  #Re-name our column names
  colnames(PRErun) <- c("match_ID",
                        "compound_name",
                        "LOBdbase_mz",
                        "peakgroup_rt",
                        "FA_total_no_C",
                        "FA_total_no_DB",
                        "species")

  ### Begin Screening

  for (k in 1:length(unique(PRErun$species))) {

    run <- PRErun[which(PRErun$species== unique(PRErun$species)[k]),]

    #Binary string for each point
    Binary_String <- rep(1, nrow(run))

    #Empty String we will build a restrictions from
    Empty_String <- rep(0, nrow(run))

    #Matrix of our Exclusions
    Exclusion_Matrix <- matrix(nrow = 1,ncol = nrow(run))

    # Run a loop to find what to exclude for each point
    for (i in 1:nrow(run)) {

      #Get our row
      subject <- run[i,]

      # Make a table to store our exclusion info
      Exclusion_Table <- run
      Exclusion_Table$Exclude <- rep(FALSE,nrow(run))

      #Lets sort the compounds run above and below our point in terms of rt
      lower_rt <- run[which(run$peakgroup_rt < subject$peakgroup_rt),]
      higher_rt <- run[which(run$peakgroup_rt > subject$peakgroup_rt),]

      #Now find ones that break the rules for lower and higher and set Exclude to TRUE in the Exclusion_Table

      #Exclude the lower
      lower_names <- row.names(lower_rt[lower_rt$FA_total_no_C>=subject$FA_total_no_C & lower_rt$FA_total_no_DB<=subject$FA_total_no_DB,])
      Exclusion_Table[lower_names,"Exclude"] <- TRUE
      #Exclude the higher
      higher_names <- row.names(higher_rt[higher_rt$FA_total_no_C<=subject$FA_total_no_C & higher_rt$FA_total_no_DB>=subject$FA_total_no_DB,])
      Exclusion_Table[higher_names,"Exclude"] <- TRUE
      #Exclude the compounds with the same name
      Exclusion_Table[which(Exclusion_Table$compound_name==subject$compound_name),"Exclude"] <- TRUE

      Exclusion_String <- Empty_String

      for (j in 1:nrow(run)) {
        if(j!=i){
          if(Exclusion_Table[j,"Exclude"]==TRUE){
            Exclusion_String <- Empty_String
            Exclusion_String[j]<-1
            Exclusion_String[i]<-1
            Exclusion_Matrix <- rbind(Exclusion_Matrix,Exclusion_String)
            rownames(Exclusion_Matrix) <- NULL
            Exclusion_Matrix <- unique(Exclusion_Matrix)
          }
        }
        cat("\r")
        flush.console()
        cat("Writing rules for",as.character(unique(PRErun$species)[k]),"compound number",i,"of",nrow(run),". Number of Rules created:",nrow(Exclusion_Matrix),"...")
      }
    }
    cat(" Done")
    Final_Exclusion_Matrix <- Exclusion_Matrix[-1,]

    if(is.null(nrow(Final_Exclusion_Matrix))){
      cat("\nCompound class to small or any lacks noise to screen.")
    }else{

      #time to screen
      dir <- rep("<=", nrow(Final_Exclusion_Matrix)) # all constraints '<='

      rhs <- rep(1, nrow(Final_Exclusion_Matrix)) # all right hand sides = 1

      #all.bin for binary. Set Solution number high to get all solutions.


      cat("\nApplying lpSolve algorythm...")
      sol <- lpSolve::lp("max", Binary_String, Final_Exclusion_Matrix, dir, rhs,all.bin = TRUE,num.bin.solns = 100)
      cat(" Done")
      numcols <- nrow(run)
      numsols <- sol$num.bin.solns

      solutions <- matrix(head(sol$solution, numcols*numsols), nrow=numsols, byrow=TRUE)

      run$Picked <- solutions[1,]
      FINAL <-run[which(run$Picked==1),]

      bar <- data.frame(colSums(solutions))
      run$Type<-rep(0,nrow(run))
      run[which(bar==0),"Type"] <- 'No_Fit'
      run[which(bar!=nrow(solutions) & bar!=0 ),"Type"] <- 'Maybe'
      run[which(bar==nrow(solutions)),"Type"] <- 'Good_Fit'

      return[return$match_ID %in% run$match_ID,"lpSolve"] <- run$Type
    }
  }

  i <- NULL
  for (i in 1:length(unique(PRErun$species))){

  run <- return[return$species == unique(PRErun$species)[1],]
  run <-run[run$match_ID %in% LOBpeaklist$match_ID,]

  print(ggplot(run,aes(x = peakgroup_rt, y = LOBdbase_mz,color=lpSolve)) +
          scale_color_manual(values=c("#e7cd08", "#e70808", "#08e799")) +
          geom_point() +
          geom_text(label=paste0(as.character(run$FA_total_no_C), ":",
                                 as.character(run$FA_total_no_DB)),
                    hjust = 1,
                    vjust = 2,
                    size=2,
                    color="black")+
          ggtitle(paste0("lpSolve Screened Data - ", as.character(run$species))) +
          xlab("Peak Group Retention Time (sec)")+
          ylab("Peak Group m/z")

  )
  if (save.files==TRUE){
  ggsave(filename = paste0(as.character(run$species), "_LP_solve.tiff"),
         plot = last_plot(),
         device = "tiff",
         width = 22, height = 17)
  }
  }

  return(return)
}
